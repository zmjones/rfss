% Exploratory Data Analysis using Random Forests[^conf]
% Zachary Jones and Fridolin Linder[^contact]

[^conf]: Prepared for the 73rd annual MPSA conference, April 16-19, 2015.
[^contact]: Zachary M. Jones is a Ph.D. student in political science at Pennsylvania State University ([zmj@zmjones.com](mailto:zmj@zmjones.com)). Fridolin Linder is a Ph.D. student in political science at Pennsylvania State University ([fridolin.linder@gmail.com](mailto:fridolin.linder@gmail.com)) his work is supported by Pennsylvania State University and the National Science Foundation under an IGERT award # DGE-1144860, "Big Data Social Science".

\begin{abstract}
The rise of ``big data'' has made machine learning algorithms more visible and relevant for social science researchers, however, they are still widely considered to be ``black box'' models that are not suited for substantive research but only for prediction. We argue that this need not be the case, and present one method, Random Forests, with an emphasis on practical application for exploratory analysis and substantive interpretation. Random forests detect interaction and nonlinearity without prespecification, have low generalization error in simulations and in many real-world problems, and can be used with many correlated predictors, even when there are more predictors than observations. Importantly, Random Forests can be interpreted in a substantively relevant way with variable importance measures, bivariate and multivariate partial dependence, proximity matrices, and methods for interaction detection. We provide intuition as well as technical detail about how Random Forests work, in theory and in practice, as well as empirical examples from the literature on american and comparative politics. Furthermore, we provide software implementing the methods we discuss to facilitate their use.
\end{abstract}

\clearpage

## Introduction

Technological development and the emergence of ``big data'' has made an abundance of new sources of data and new techniques of data analysis available to social scientists. This has triggered a debate in political science on how useful these new sources of data and the methods of analysis that come with them are for social scientific inquiry and how compatible they are with classic approaches in political science [@clark2015big]. An important component of the new developments is the prominence of machine learning algorithms. Although they have been used for a long time in computer science and related disciplines, only through the recent developments they have become more visible to social science researchers. These methods, also referred to as data mining methods, statistical learning methods, or algorithmic models, were initially developed to maximize predictive performance, and are most prominently employed for rather atheoretical tasks. For this reason, they are often considered to be black boxes that deliver good predictions, but are not very useful for theory driven work of scholars seeking substantive insight [@breiman2001statistical].

Although algorithmic methods have spawned some interest in the political methodology literature [@beck1998beyond; @beck2000improving; @hainmueller2013kernel; @imai2013estimating] and have been used for applied work in a few instances  [@grimmer2013text; @hill2014empirical; @dorazio2015theres], they are not very prominent in applied political science research. We argue that the new developments in the area of machine learning should not be seen as incompatible with traditional avenues of political science research but rather as a useful extension of the data analysis and inference tools that are available to researchers [@monroe2015no]. In order to support this claim, in this paper we demonstrate the usefulness of a well established machine learning algorithm - Random Forests - for applied political science research. In particular, we show how substantive insights for exploratory data analysis (EDA) can be obtained from the Random Forest algorithm.

Although EDA is not very prominent in published work in political science, it can be viewed as a basic building block of every scientific agenda [@tukey1977exploratory; @gelman2004exploratory; @shmueli2010explain]. Especially in settings where only observational data is available, and the observations are generated from a complex processes, EDA can prove useful to induce theoretical development, generate hypotheses that can be tested with confirmatory designs later. A good example for such a strategy is King et al.'s work on censorship in China, where observational data generated the hypothesis that censorship mostly aims at collective action, which was then tested in an experimental design [@king2013censorship; @king2014reverse; @monroe2015no]. 

The Random Forest algorithm has received little attention in political science[^exceptions]. In this paper, we demonstrate that it is a useful tools for EDA because of its flexibility to discover a variety of interesting structures in the data without the necessity to employ specialized methods to look for them. For instance, after the model is fitted to the data, information about nonlinear relationships, interactions and clustering of observations can be easily extracted from it.

Random Forests can be easily used with all common forms of outcome variables: continuous, discrete, censored (survival), and multivariate combinations thereof. Furthermore, they do not require distributional assumptions. They can approximate arbitrary functional forms between explanatory and outcome variables, making it easy to discover complex nonlinear relationships that with many standard methods would miss if not explicitly specified [@wager2015uniform; @fernandez2014we]. These relationships can be visualized and interpreted using partial dependence plots. Furthermore, Random Forests are capable of detecting interactions of any order between predictors, without specifying them in advance. Graphical and maximal subtree methods can be used to extract and substantively interpret these interactions. The importance of variables can be assessed by their impact on the accuracy of predictions, which allows for a quick assessment of the relevance of a predictor for the outcome of interest. Finally, Random Forests can be used to obtain a measure of the similarity of observations in the predictor space, which, especially when units are named (e.g. countries), may provide insight into similarities that may not be obvious, and provides further information about the importance of explanatory variables.

In this paper, we provide an accessible introduction to the algorithm and the methods used to extract substantive insights mentioned above. First we give an introduction to classification and regression trees (CART) that are the basic building blocks of the Random Forest. We then describe their combination into an ensemble that is the Random Forest. In the remainder of the paper we describe methods that can be used to extract substantive insights from the fitted forest. We illustrate these methods using two applications. One is based on data from a recent turnout experiment on ex-felons in Connecticut [@gerber2014can]. The other uses data on the country level predictors for respect for human rights [@hill2014empirical; @fariss2014respect] There are several packages in \texttt{R} to fit Random Forests, however, the methods to extract substantive insight are insufficiently general, do not exploit parallelization when it is possible, are only available in some packages, lack a consistent interface, and lack the ability to generate publication quality visualizations. Therefore, accompanying to this paper, we developed an \texttt{R} package, that allows to easily compute and visualize these methods for EDA with all of the major Random Forest \texttt{R}-packages[^edarf].

[^exceptions]: Although there have been some exceptions [@grimmer2015we; @hill2014empirical].
[^edarf]: The package is currently available in its development version at <https://github.com/zmjones/edarf>. The packages supported are [party](http://cran.r-project.org/web/packages/party/index.html) (`cforest`), [randomForest](http://cran.r-project.org/web/packages/randomForest/index.html), and [randomForestSRC](http://cran.r-project.org/web/packages/randomForestSRC/index.html) (`rfsrc`).

## Random Forests

The Random Forest algorithm as first proposed by @breiman2001random is a so called ensemble method. This means, the model consists of many smaller models, but predictions and other quantities of interest are obtained by combining the outputs of all the smaller models. There are many ensemble methods that consist of various sub-models. The sub-models for Random Forests are classification and regression trees (CART). The key to understanding how the Random Forest works, is to understand CART. Therefore, in the next sections we first give a more detailed introduction to CART and then continue with the combination of the trees to an ensemble.

### Classification and Regression Trees

CART are a regression method that relies on repeated partitioning of the data to estimate the conditional distribution of a response given a set of predictors. Let the outcome of interest be a vector of observations $\mathbf{y} = (y_1,\ldots,y_n)^T$ and the set of explanatory variables or predictors a matrix $\mathbf{X} = (\mathbf{x}_1,\ldots,\mathbf{x}_p)$, where $\mathbf{x}_j = (x_{1j},\ldots,x_{nj})^T$ for $j \in \{1,\ldots,p\}$. The goal of the algorithm is, to partition $\mathbf{y}$ conditional on the values of $\mathbf{X}$ in such a way that the resulting subgroups of $\mathbf{y}$ are as homogeneous as possible.

The algorithm works by considering every unique value in each predictor as a candidate for a binary split, and calculating the homogeneity of the subgroups of the outcome variable that would result by grouping observations that fall on either side of this value. Consider the (artificial) example in Figure \ref{fig:cart_visu}. $\mathbf{y}$ is the vote choice of $n = 40$ subjects (18 republicans and 22 democrats), $\mathbf{x}_1$ denotes subjects' ideology and $\mathbf{x}_2$ their age. 

The goal of the algorithm is to find homogeneous partitions of $\mathbf{y}$ given the predictors. The algorithm starts at the upper right panel of Figure \ref{fig:cart_visu}, the complete data is the first node of the tree. We could classify all cases as Democrats yielding a misclassification rate of $18/40 = 0.45$. But it is obvious that there is some relationship between ideology and vote choice, so we could do better in terms of classification error using this information. Formally the algorithm searches through all unique values of both predictors and calculates the number of cases that would be misclassified if a split would be made at that value and all cases on the left and right of this split are classified according to majority rule. The upper right panel displays this step for one value of ideology (which also turns out to be the best possible split). In the tree in the lower left panel of Figure \ref{fig:cart_visu} the split is indicated by the two branches growing out of the first node. The variable name in the node indicates that the split was made on ideology. To the left of an ideology value of $3.31$ most of the subjects voted Republican and on the right most voted Democrat. Therefore we classify all cases on the left and right as Republican and Democrat respectively (indicated by the shaded areas in the scatterplots). Now only 8 cases are misclassified, yielding an error rate of $8/40 = 0.2$.

![Visualization of a recursive partitioning algorithm for classification. The upper left panel displays the original data. The two panels on the right display the partitions of the original data after the first and the second split respectively. The lower left panel displays the corresponding decision tree. The blue and red shaded areas in the right panels indicate the value for the fitted value of the terminal node. The shading of the area visualizes classification as Republican (red) or Democrat (blue) by majority rule. The red colored letters indicate incorrect classifications under this rule. \label{fig:cart_visu}](figures/cart.png)

The algorithm then looks for further splits within the two new partitions (left and right of $c_{x_1} = 3.21$. It turns out that for the right side there is no split that decreases the misclassification rate sufficiently (we talk about the criteria for making stopping decisions later). This is shown in the tree as a so called terminal node on the right branch of the ideology split. The plot in the terminal node displays the distribution of the outcome in this partition of the data. 

However, age still contains information to improve the partitioning. At the second node (i.e. all data that falls left of the first split), when splitting the data into subjects older or younger then 51 years, we can obtain a completely homogeneous partition where all subjects voted Republican. Additionally those subjects older then $51$ and with an ideology value lower than $3.21$ are now classified as democrats. Note that the four democratic cases in this region of the data, which were misclassified before, are now correctly classified. The three republicans in the upper right partition are now misclassified. The classification error has therefore been reduced from $8/40$ to $6/40$.

We now extend the logic of CART from this very simple example of binary classification with two continuous predictors to other types of outcome variables. When extending the algorithm to other types of outcome variables we have to think about loss functions explicitly. In fact, we used a loss function in the illustration above. We calculated the classification error when just using the modal category of the outcome variable and argued that further splits of the data are justified because they decrease this error. More formally let $\mathbf{y}^{(m)} = (y^{(m)}_1,\ldots, y^{(m)}_{n^{(m)}})$ and $\mathbf{X}^{(m)} = (\mathbf{x}^{(m)}_1,\ldots,\mathbf{x}^{(m)}_p)$ be the data at the current node $m$, $\mathbf{x}^{(m)}_s$ the predictor that is to be used for a split, with unique values $\mathcal{C}^{(m)} = \{x^{(m)}_i\}_{i\in \{1,\ldots,n^{(m)}\}}$ and $c \in \mathcal{C}^{(m)}$ the value considered for a split. Then the data in the daughter nodes resulting from a split in c are $\mathbf{y}^{(m_l)}$ and $\mathbf{y}^{(m_r)}$. Where $\mathbf{y}^{(m_l)}$ contains all elements of $\mathbf{y}^{(m)}$ whose corresponding values of $\mathbf{x}^{(m)}_s \leq c$ and $\mathbf{y}^{(m_r)}$ all elements where $\mathbf{x}^{(m)}_s > c$. The gain (or reduction in error) from a split at node $m$ in predictor $\mathbf{x}_s$ at value $c$ is defined as:
\begin{equation}
  \label{eq:loss}
  \Delta(\mathbf{y}^{(m)}) = L(\mathbf{y}^{(m)}) - \left[\frac{n^{(m_l)}}{n^{(m)}} L(\mathbf{y}^{(m_l)}) +  \frac{n^{(m_r)}}{n^{(m)}} L(\mathbf{y}^{(m_r)})\right]
\end{equation}

Where $n^{(m_l)}$ and $n^{(m_r)}$ are the number of cases that fall to the right and to the left of the split, and $L(\cdot)$ is the loss function. 

In the example above we made the intuitive choice to use the number of cases incorrectly classified when assigning the mode as the fitted value, divided by the number of cases in the node, as the loss function. In order to return to the goal stated above, to obtain homogeneous partitions of the data, this proportion can also be interpreted as the impurity of the data in the node. Therefore it is intuitive to use the amount of impurity as a measure of loss. This is how the algorithm can be used for outcomes with more than two unique values (i.e. for nominal or ordinal outcomes with more than two categories, or continuous outcomes). By choosing a loss function that is appropriate to measure the impurity of a variable at a certain level of measurement, the algorithm can be extended to those outcomes.

For categorical outcomes, denote the set of unique categories of $\mathbf{y}^{(m)}$ as $\mathcal{D}^{(m)} = \{y^{(m)}_i\}_{i\in\{1,\ldots,n^{(m)}\}}$. In order to asses the impurity of the node we first calculate the proportion of cases pertaining to each class $d \in \mathcal{D}^{(m)}$ and denote it as $p^{(m)}(d)$. Denote further the class that occurs most frequent as $\hat{y}^{(m)}$. The impurity of the node in terms of  misclassification is then obtained from:

\begin{equation}
  \label{eq:misclass}
  L_{mc}(\mathbf{y}^{(m)}) = \frac{1}{n^{(m)}} \sum_{i=1}^{n^{(m)}} \mathbb{I}(y^{(m)}_i \neq \hat{y}^{(m)}) = 1 - p^{(m)}(\hat{y}^{(m)})
\end{equation}

Where $\mathbb{I}(\cdot)$ is the indicator function that is equal to one when its argument is true. This formalizes the intuition used above: the impurity of the node is the proportion of cases that would be misclassified under majority rule[^asym_loss].

[^asym_loss]: The other two loss functions that are most often used are the Gini loss $L_{\text{gini}}(\mathbf{y}^{(m)}) = \sum_{d \in \mathcal{D}^{(m)}} p^{(m)}(d)[1-p^{(m)}(d)]$, and the entropy of the node $L_{\text{ent}}(\mathbf{y}^{(m)}) = -\sum_{d \in \mathcal{D}^{(m)}} p^{(m)}(d)\log[p^{(m)}(d)]$. Extensive theoretical [e.g. @raileanu2004theoretical] and empirical [e.g. @mingers1989empirical] work in the machine learning literature concluded that the choice between those measures does not have a significant impact on the results of the algorithm.

A different loss function is required to measure the impurity of the node, when the outcome is continuous. Usually the mean squared error (MSE) is used[^survival]:

[^survival]: If yet another loss function is employed, the Random Forest algorithm can also be applied to censored data. See @ishwaran2008random and @hothorn2006survival for details.

\begin{equation}
  \label{eq:mse}
  L_{\text{mse}}(\mathbf{y}^{(m)}) = \sum_{i=1}^{n^{(m)}} (y^{(m)}_i - \hat{y}^{(m)})^2
\end{equation}

Where the predicted value $\hat{y}^{(m)}$ is usually the mean of the observations in $\mathbf{y}^{(m)}$. The extension to ordered discrete predictors is straightforward. Since the observed values of a continuous random variable are discrete, the partitioning algorithm described above works in the same way for ordered discrete random variables. 

Unorderd categorical variables are handled differently. If a split in category $c$ of an unordered discrete variable is considered, the categorization in values to the left and to the right of $c$ has no meaning since there is no ordering to make sense of "left" and "right." Therefore all possible combinations of the elements of $\mathcal{D}^{(m)}$ that could be chosen for a split are considered. This can lead to problems for variables with many categories. For an ordered discrete variable the number of splits that the algorithm has to consider is $|\mathcal{D}^{(m)}|-2$, however, for an unordered variable it is $2^{|\mathcal{D}^{(m)}|-1}-1$. This number gets large very quickly. For example the inclusion of a country indicator might be prohibitive if there are more than a handful of countries (e.g. if there are 21 countries in the sample the number of splits that have to be considered for that variable at each node is more than a million). Solutions to that problem are to include a binary variable for each category or to randomly draw a subset of categories at each node [see @louppe2014understanding, for details on the latter method].

After a loss function is chosen, the algorithm proceeds as described in our example. At each node $m$, $\Delta(\mathbf{y}^{(m)})$ is calculated for all variables and all possible splits in the variables. The variable-split combination that produces the highest $\Delta$ is selected and the process is repeated for the data in the resulting daughter nodes $\mathbf{y}^{(m_l)}$ and $\mathbf{y}^{(m_r)}$ until a stopping criterion is met. The stopping criterion is necessary to avoid trees that are too complex and therefore over fit the data. Theoretically a tree could be grown until each observation has its own terminal node. This tree would do perfectly on the data it was fitted to but would perform very poorly on new data, because all the noise of the training data is included in the model. A stopping criterion is therefore a method to find a balance between a tree that is too complex and overfits the data and a tree that is too simple and therefore smooths over important details. This mirrors the bias-variance tradeoff relevant to all statistical models [@hastie2009elements ;@farissjones2015]. Stopping criteria that are commonly used include the depth of the tree (how many levels of splits does the tree have), the number of observations in the terminal nodes or the homgeneity of the distributions in the terminal nodes. The right choice of a value for these criteria depends on the problem at hand and should be understood as a tuning parameter. That means, they should be chosen to minimize the expected generalization error, for example by using cross validation.

Once the tree is completely ``grown'', a predicted value for each observation is obtained by assigning a summary statistic for the terminal node the observation ended up in. For continuous data usually the mean of the distribution in the terminal node is used. For categorical data, either the majority category, or a vector of predicted probabilities for each category is assigned. Figure \ref{fig:cart_approx} illustrates how the predicted values from CART approximate the function connecting the outcome and the predictor. The blue line displays the fitted values from a regression tree fitted to the data. The piecewise constant shape of the fitted values stems from the fact that all observations in one terminal node are assigned the same fitted value (in this case the mean of this node). Although the relationship is highly nonlinear, the algorithm does a decent job in recovering the sine structure.  

\input{figures/latex_subfloats/approximation.tex}

Predicted values for new data can be obtained in a straightforward manner. Starting at the first node of the tree, a new observation $i$ is "dropped down the tree", according to its values of the predictors $(x_{i1},...,x_{ip})$. That is, at each node the observation is either dropped to the right or the left daughter node depending on its value on the predictor that was used to make a split at that node. This way, each new observation ends up in one terminal node. Then the predicted value of this terminal node is assigned as the prediction of the tree for observation $i$.

As previously mentioned CART has two main problems: fitted values have high variance and there is a substantial risk of overfitting. Fitted values can be unstable, producing different classifications when changes to the data used to fit the model are made (i.e., the estimator has high variance). [WHAT FOLLOWS IS A BIT UNCLEAR] There are several related reasons why this occurs. The first is that CART is locally optimal, that is, each split is optimal only at the node at which it occurs. Globally optimal partitioning is generally computationally intractable. Instead heuristic algorithms that are locally optimal (greedy) are used.[^global] Given this locally optimal optimization, order effects result, that is, the order in which the variables are split can result in different resulting tree structures, and thus, different predictions. Random Forests, which we discuss in the next section, have much lower variance and remove the effects of ordering.

[^global]: Though see @grubingerevtree for an example of a stochastic search algorithm for this problem.

### Combining the Trees to a Forest

@breiman1996bagging proposed bootstrap aggregating, commonly called ``bagging'', to decrease the variance of fitted values from CART. This innovation also can be used to reduce the risk of overfitting. The core idea of bagging is to decrease the variance of the predictions of one model, by fitting several models and averaging over their predictions to obtain one regularized prediction. In order to obtain a variety of models, that are not customized to the data set at hand, each component model is fit only to a bootstrap sample of the data. A bootstrap sample is a sample of the same size as the original data set, but drawn with replacement. Therefore, each of those samples excludes some portion of the data, which is referred to as ``out-of-bag'' (OOB) data. In order to build a Random Forest, a CART is fit to each of the bootstrap samples. Then, each tree makes predictions for the OOB data by dropping it down the tree that was grown without that data. Thus each observation will have a prediction made by each tree where it was not in the bootstrap sample drawn for that tree. The predicted values for each observation are combined to produce an ensemble estimate which has a lower variance than would a prediction made by a single CART grown on the original data. For continuous outcomes the predictions made by each tree are averaged. For discrete outcomes the majority class is used (or the predicted probabilities are averaged. Relying on the OOB data for predictions also eliminates the risk of overfitting since the each tree's prediction is made with data not used for fitting.

Additionally to ``bagging'' the Random Forest algorithm contains another innovation. @breiman2001random extended the logic of bagging to predictors. That means, instead of choosing from all predictors for the split at each node in each tree, only a random subset of the predictors is used. This might seem counterintuitive at first, but it has the effect of diversifying the splits across trees: If there are some very important variables, they might overshadow the effect of weaker predictors, because, the algorithm searches for the split that results in the highest reduction in impurity. If at each split only a subset of predictors is chosen, weaker predictors get a chance to be selected more often, reducing the risk of overlooking such variables. Bagging of predictors yields the additional advantage, that a very large set of predictors can be analyzed with the random forest. If the number of predictors is very large if there are enough trees in the ensemble, all variables relevant variables get chosen for splits eventually, and their impact can be analyzed (see the later sections on how to extract substantive information from the Random Forest).  This results in a further decrease in the variance of the fitted values (beyond bagging observations) and allows [WHY?]. 

A particular observation can fall in the terminal nodes of many trees in the forest, each of which, potentially, can give a different prediction. Again the OOB data, that is, data that was *not* drawn in the bootstrap sample used to fit a particular tree, is used to make each tree's prediction. For continuous outcomes, the prediction of the forest is then the average of the predictions of each tree:

\begin{equation}
  \label{eq:rf}
  \hat{f}(\mathbf{X}) = \frac{1}{T} \sum_{t=1}^T f^{(t)}(\mathbf{X}_{i \in \bar{\mathcal{B}}^{(t)}})
\end{equation}

where $T$ is the total number of trees in the forest, and $f^{(t)}(\cdot)$ is the $t$'th tree, $\bar{\mathcal{B}}^{(t)}$ is the out-of-bag data for the $t$'th tree, that is, observations in $\mathbf{X}^{(t)}$ and not in $\mathcal{B}^{(t)}$, the bootstrap sample for the $t$'th tree. For discrete outcomes, the prediction is the majority prediction from all trees that have been grown without the respective observation or the average of the predicted probabilities. Figure \ref{fig:rf_approx} displays the approximation to a function relating a continuous outcome to a single predictor obtained from a random selection of 25 trees from a Random Forest. The blue lines display the predictions from the single trees, and the smoothed red line represents the prediction from the forest. It can be observed that the approximation is much smoother compared to the approximation by a single tree (Figure \ref{fig:cart_approx}.

The number of candidate predictors available at each node and the number of trees in the forest are again tuning parameters and the optimal choice depends on the data and task at hand. Therefore, they should be chosen to minimize expected generalization error for example by using resampling methods such as cross validation. Random Forests compare favorably with other popular nonparametric methods in prediction tasks and can be interpreted substantively as well as we will show in the following sections [see e.g., @breiman2001random; @breiman2001statistical; @cutler2007random; @murphy2012machine; @hastie2009elements].

## Exploratory Data Analysis and Substantive interpretation 

As could be seen in the section on CART, a single tree is relatively easy to interpret. It can be visualized as in \ref{fig:cart_visu} and directly interpreted. But how is it possible to interpret a thousand trees, every single one only fit to a sample of the data, and using a random sample of explanatory variables on each split? Because the Random Forest is an ensemble, it would be fruitless to try to extract substantive insight from its pieces. However, several methods have been developed to extract more information than just predictions from the Random Forest. In this section we explain these methods how to interpret them substantively using visualizations from our \texttt{R} software package. 

In order to illustrate the practical application of Random Forests for EDA, we use two data examples from recently published political science studies. The first is a turnout study on released prisoners [@gerber2014can]. This dataset contains information on the experimental treatments as well as four additional covariates, on over 5000 former inmates from Connecticut prisons that were released and whose voting rights have been restored. As the treatment @gerber2014can sent letters with two different treatments (the control group was not contacted), encouraging them to register and vote. Turnout and registration rates were recorded. The authors found that their treatment had positive effects on registration and turnout. Since registration and turnout rates are very low in this population and in order to avoid a very imbalanced outcome, we use the subsample of registered prisoners and use their turnout as the outcome. We chose this data set to show that Random Forests are useful not only in classical data mining applications with large numbers of predictors, but also for analysis in more standard political science applications.

As the second data set we consider data from a recent study of cross-national patterns of state repression [@hill2014empirical]. Quantitative analysis of cross-national patterns of state repression relies on annual country reports from Amnesty International and the United States Department of State, which are used to code ordinal measures of state repression such as the Cingranelli and Richards Physical Integrity Index and the Political Terror Scale [@ciri2010; @woodgibney2010]. We use the measure from @fariss2014respect which is based on a dynamic measurement model, which aggregates information from multiple sources on state repression in each country-year into a continuous measure. @hill2014empirical use data from 1981 to 1999 in their original study, however, the Random Forest algorithm assumes independent data (see the later section on limitations). Since the measures of state repression are highly correlated over time within countries, for the purpose of this demonstration we use data just from 1999. The data set contains data on 190 countries. We use a set of explanatory variables that differs slightly from that of @hill2014empirical, containing some predictors that may be relevant but were omitted, and some predictors, such as the participation competitiveness component of Polity IV, and binary indicators for civil war, which have conceptual overlap with respect for physical integrity rights and should be omitted on those grounds [@hill2014empirical; @hill2014democracy]. This data is well suited for exploratory data analysis using Random Forests because we have no expectation that the relationship between any particular predictor (that is not binary) will have a linear (or even smooth) relationship with our measure of respect for physical integrity rights, nor do we have expectations about the number or size of any interactions that may be present in the data. However, we would like to discover such relationships if they exist. Additionally, by studying the latent similarity of countries in the predictor space, we hope to notice features of countries close in this space which we do not have data on, and might be fruitful areas of future research. 

### Permutation Importance

The standard measure of variable importance for Random Forests is permutation importance. The marginal permutation importance shows the mean decrease in prediction error that results from randomly permuting an explanatory variable. If a particular column of $\mathbf{X}$, say $\mathbf{x}_j$, is unrelated to $\mathbf{y}$, then randomly permuting $\mathbf{x}_j$ within $\mathbf{X}$ should not meaningfully decrease the model's ability to predict $\mathbf{y}$[^rndsplit]. However, if $\mathbf{x}_j$ is strongly related to $\mathbf{y}$, then permuting its values will produce a systematic decrease in the model's ability to predict $\mathbf{y}$, and the stronger the relationship between $\mathbf{x}_j$ and $\mathbf{y}$, the larger this decrease. Averaging the amount of change in the fitted values from permuting $\mathbf{x}_j$ across all the trees in the forest gives the marginal permutation importance of a predictor[^marginal]. Formally, for classification, the importance of explanatory variable $\mathbf{x}_j$ in tree $t \in T$ is:

[^rndsplit]: There are other methods of measuring variable importance. @ishwaran2007variable for example proposed to use the distance of the first split on a variable from the root node of the tree as a measure of importance. This measure uses the fact that important variables are selected early in the partitioning algorithm (see also the section on interaction detection in this paper). However, permutation importance is the most widely used measure of variable importance, we therefore refer the reader to the relevant literature for more details on alternative methods. 

[^marginal]: This measure is not truly marginal since the importance of a variable within a particular tree is conditional on all previous splits in the tree. It is possible to conduct a conditional permutation test which permutes $\mathbf{x}_j$ with variables related to $\mathbf{x}_j$ "held constant," reducing the possibility that a variable is deemed important when it is actually spurious [@strobl2008conditional]. However, this procedure is prohibitively costly in terms of computational resources.

\begin{equation}
  \label{eq:imp}
  \text{VI}^{(t)}(\mathbf{x}_j) = \sum_{i \in \bar{\mathcal{B}}^{(t)}} L(y_i, \hat{y}_i^{(t)}) -
  \sum_{i \in \bar{\mathcal{B}}^{(t)}} L(y_i, \hat{y}_{i \pi j}^{(t)})
\end{equation}

\begin{equation}
  \label{eq:imp_av}
  \text{VI}(\mathbf{x}_j) = \frac{1}{T} \sum_{t=1}^T \text{VI}^{(t)}(\mathbf{x}_j)
\end{equation}

where $\bar{\mathcal{B}}$ is the out-of-bag data for tree $t$, $\mathbf{x}_j$ is a particular predictor, $\hat{y}_i^{(t)}$ is the fitted value for observation $i$ in tree $t$, and $\hat{y}_{i \pi j}^{(t)}$ is the fitted value for the $i$'th observation after permuting $\mathbf{x}_j$. $L(\cdot)$ is the loss function (e.g., Equations \ref{eq:misclass} and \ref{eq:mse}), which depends on whether $\mathbf{y}$ is discrete, continuous, etc. In other words, the importance in a single tree is simply the difference between the predictive accuracy (measured on the out-of-bag data) before and after permuting $x_j$ (Equation \ref{eq:imp}). The importance of variable $\mathbf{x}_j$ in tree $t$ is averaged across all trees to give the permutation importance for the forest (Equation \ref{eq:imp_av}) [@breiman2001random; @strobl2008conditional]. For classification the loss function usually used is the misclassification loss, and for regression the mean squared error. Our software provides a unified extractor for permutation importance calculated by Random Forests in \texttt{R} as well as plotting functionality.

\input{figures/latex_subfloats/permutation_importance.tex}

Figure \ref{fig:imp} displays the permutation importance for the two data examples as produced by \texttt{edarf}. Figure \ref{fig:latent_imp} shows the importance of the explanatory variables for respect for human rights. Since the latent outcome in this example is a continuous variable, the importance is measured by the increase in mean squared error (MSE) from permuting the variable of interest. For example, randomly permuting the column related to Judicial Independence in the data set, dropping down this new data set all the trees, measuring the difference in predictive accuracy for each tree, and averaging over these measures for the forest results in an increase in MSE of about 0.4. This measure can be used to assess the predictive importance of variables relative to each other. Although not suprising in light of @hill2014empirical, it is clear that most of the predictors have little to no predictive power and that internal features of the countries in question are the most important in terms of predictive power.

Figure \ref{fig:imp_cond_vote} displays the permutation importance for the prisoners example. The scale of this measure is the increase in misclassification error as described in Equation \ref{eq:imp}. The predictive accuracy of the model is generally very bad, because the variables available do not contain much information on the decision to vote. The only variable that significantly contributes to the predictive accuracy of the model is if the subject voted in the previous election. Permuting this variable decreases the accuracy of the classification in voters and non-voters by about 2\%. The other predictors have negative importance, which indicates that they are not useful in predicting whether or not registered ex-felon's voted in this sample.

This short exposition showed that permutation importance can be a useful tool to get a rough assessment of the predictive importance of the variables in the model. However, the usefulness of this measure of variable importance depends on the goals of the researcher. Since it is a measure of predictive importance it does not tell us anything on the causal importance of a variable. In order to find such effects, causal identification has to be provided through the research design. However, estimation of such effects is not the goal of EDA. For EDA, permutation importance is a useful tool to get a rough assessment of the importance of potentially theoretically interesting variables. Especially in cases where many predictors are available, but little theory on important variables, this importance measure provides the possibility to easily screen for important variables.

This is an attractive alternative to null hypothesis significance testing, which is often used heuristically for this purpose [@hill2014empirical; @ward2010perils; @gill1999insignificance]. NHST can be thought of as giving a measure of surprise under the assumption of the null (e.g. that a regression coefficient is exactly zero) with a particular type of stochastic variability assumed from the model. However, this can be misleading when no assumed model is determined by theory, and, consequently, it is likely that the model is misspecified, perhaps severely. It can also be misleading when this logic does not comport with the analysts' use of the word "importance." In situations where causal identification is difficult or impossible, predictive importance is a reasonable way to define and measure "importance." Additionally, this measure comes from a method which does not specify a particular generative structure on the data, and hence measures of importance include direct and indirect associations (i.e., dependence of the outcome on a variable and all interactions that are detected with that variable). This decreases the chance that a variable could be missed if its direct effects are masked or dwarfed by its indirect effects.

[SHOULD WE ADD SOMETHING ON THE EPISTEMOLOGICAL QUESTIONS RELATED TO PREDICTIVE PERFORMANCE AS MEASURE OF THEORETICAL IMPORTANCE?] 

### Partial Dependence

Although the predictive importance of a variable can often be very insightful, most scholars are interested in how the variable is related to the outcome. Partial dependence is a simple method, again based on predictions from the forest, to visualize the partial relationship between the outcome and the predictors [p. 369, @hastie2009elements]. Partial dependence provides the ability  to visualize the relationship between $\mathbf{y}$ and one or more predictors $\mathbf{x_j}$ as detected by the Random Forest. The basic intuition is to obtain a prediction from the Random Forest for each value of $\mathbf{x_j}$ (or of each value combination if there are multiple variables of interest) accounting for the effects of the other variables. Plotting these predictions against the unique values of $\mathbf{x_j}$ then displays how $\mathbf{y}$ is related to $\mathbf{x_j}$ according to the model. Since the Random Forest can approximate almost arbitrary functional relationships between $\mathbf{x_j}$ and $\mathbf{y}$ -- as shown in Figure \ref{fig:rf_approx} -- the model is able to detect non-linear relationships without the need to pre-specify them. This allows to detect potentially interesting non-linearities in settings where little a priori theoretical knowledge allows for pre-specification of specific forms. This is one of the main strengths of Random Forests for exploratory analyses.

The basic way partial dependence works is the following: for each value of the variable of interest, a new data set is created, where all observations are assigned the same value of the variable of interest. Then this data set is dropped down the forest, and a prediction for each observation is obtained. By averaging over these predictions, an average prediction, for a synthetic data set where the variable of interest is fixed to a particular value, and all other predictors are left unchanged is obtained. This is similar in spirit to integrating over the variables that are not in the subset of interest, however, since we have no explicit probability model, we use this empirical procedure. Repeating this for all values of the variable of interst gives the relationship between said variable and the outcome over its range. In more detail, the partial dependence algorithm works as follows:

 1. Let $\mathbf{x}_j$ be the predictor of interest, $\mathbf{X}_{-j}$ be the other predictors, $\mathbf{y}$ be the outcome, and $\hat{f}(\mathbf{X})$ the fitted forest.
 2. For $\mathbf{x}_j$ sort the unique values $\mathcal{V} = \{\mathbf{x}_j\}_{i \in \{1, \ldots, n\}}$ resulting in $\mathcal{V}^*$, where $|\mathcal{V}^*|=K$. Create $K$ new matrices $\mathbf{X}^{(k)} = (\mathbf{x}_j = \mathcal{V}^*_k, \mathbf{X}_{-j}), \: \forall \, k = (1, \ldots, K)$.
 3. Drop each of the $K$ new datasets, $\mathbf{X}^{(k)}$ down the fitted forest 
 resulting in a predicted value for each observation in all $k$ datasets: $\hat{\mathbf{y}}^{(k)} = \hat{f}(\mathbf{X}^{(k)}), \: \forall \, k = (1, \ldots, K)$.
 4. Average the predictions in each of the $K$ datasets, $\hat{y}_k^* = \frac{1}{n}\sum_{i=1}^N \hat{y}_i^{(k)}, \: \forall \, k = (1, \ldots, K)$.
 5. Visualize the relationship by plotting $\mathbf{V}^*$ against $\hat{\mathbf{y}}^*$.

The average predictions obtained from this method are more than just marginal relationships between the outcome and the predictor. Since each of the predictions are made using all the information in all the other predictors of an observation, the prediction obtained from the partial dependence algorithm also contains this information. This means that the relationship displayed in a partial dependence plot contains all the relation between $x_j$ and $y$ including the averaged effects of all interactions of $x_j$ with all the other predictors $\mathbf{X}_{-j}$, which is why this method gives the partial dependence rather than the marginal dependence.

Our software provides a method to compute $k$-way partial dependence (i.e., interactions of arbitrary dimension or many two-way partial dependencies) for continuous, binary, categorical, censored, and multivariate outcome variables. Note again that partial dependence differs from obtaining predictions for $\mathbf{y}$ with $(\mathbf{x}_j, \mathbf{x}_{-j})$ fixed. Instead partial dependence gives predictions for $\mathbf{y}|\mathbf{x}_j$ given the average effects of $\mathbf{x}_{-j}$ [p. 369-371 @hastie2009elements].

\input{figures/latex_subfloats/partial_dependence.tex}

Figure \ref{fig:pd} diplays the partial dependence for our example data sets. Figure \ref{fig:latent_pd} displays the relationships of selected predictors with the latent outcome variable. Figure  \ref{fig:pd_cond_vote} shows the results for the prisoners example. Note that the partial dependence plots in \ref{fig:latent_pd} additionally contain error bars for the predictions, whereas there are no such bars in the plots for the prisoners example. Estimating sampling uncertainty for predictions from ensemble algorithms such as random forests is a relatively new area of research [@sexton2009standard; @wager2014confidence; @mentch2014ensemble]. @wager2014confidence developed a method -- the bias-corrected infinitesimal jackknife (BIJ) to produce variance estimates for predictions from Random Forests. However, this method works only for continuous outcomes and not for classification. We implemented the BIJ in our \texttt{R} package to produce uncertainty intervals for partial dependence plots. Since this is a topic of ongoing research, and there are other proposed approaches, we expect to extend our software to these approaches [see e.g. @hooker2004discovering].

The partial dependence is interpreted as the predicted value for a particular value of an explanatory variable averaged within the joint values of the other predictors. This is similar to the interpretation of outputs from other parametric, semi-parametric, or non-parametric regression methods. In the human rights example, the partial dependence reveals some interesting nonlinearities in the relationship between the latent respect for human rights and the explanatory variables. For instance, the most important variable, according to permutation importance, de-facto judicial independence, seems to have it's biggest effect[^effect] going from two, "somewhat independent" to 3, "mostly independent," rather than from 0, "not independent" to 2 "mostly independent." The algorithm predicts an average value of about 0.3 on the latent respect for human rights scale for countries that have a value of one on the judicial independence measure. For countries with "mostly independent" judiciaries, the algorithm predicts average respect of around one (see @fariss2014respect for the interpretation of the latent scale). Recall that the value of the judicial independence measure shown on the $x$-axis is *assigned* (though each value was observed in the data), and predictions averaged over the other predictors. In the process of computing partial dependence observations which do not exist in the data are created, that is, the algorithm interpolates and extrapolates over areas of the space spanned by the predictors which may have low density. Although our software allows users to override this option, by default only values of $\mathbf{x}_j$ that are observed are used.

For the prisoners example, the $y$-axis of the partial dependence plots is the averaged predicted probability to vote given that the subject registered. For the time since release the algorithm discovered a u-shaped relationship. The plot for the ordinal treatment shows that the "assurance" condition possibly had an effect on the probability of turnout given registration, but that the "assurance expanded" condition did not. There does not appear to be interaction between the treatment conditions and the number of years since an individual was released.

[^effect]: Note, that the word effect does not imply a causal effect. The relationships discovered by the are just statistical dependencies in the data that have to be interpreted with the same care as partial correlation obtained, e. g. from regression models without causal identification.

### Interaction Detection

Partial dependence can also be used to visualize interactions the algorithm may have found. One way to do this, is to create a dataset for each of the possible combinations of unique values of the explanatory variables that are involved in the interaction of interest, and calculate the partial dependence for each of these pairs, as described in the previous section. Figure \ref{fig:int_prison} shows this procedure to for an interaction between the treatment and the years since release. The three panels correspond to the three experimental groups. An interaction is detected if the shape of the relationship of one variable with the outcome changes across levels of the other variable. In Figure \ref{fig:pd_prison} there is a shift in the probability to vote, but the shape of the relationship does not change, indicating that the algorithm has not detected any interaction.

\input{figures/latex_subfloats/interaction.tex}

In this case we are examining a possible interaction between  one continuous variable and one discrete variable with only three values, however, if the variables involved in a potential interaction are both continuous or categorical with many levels, two problems occur. First, it would be computationally prohibitive to calculate the partial dependence for all combinations of values of the two variables. For instance, if analyzing the interaction between two variables with $50$ and $100$ unique values, $50 \times 100 = 5000$ data sets would have to be created and processed by the partial dependence algorithm. Second, the visualization becomes more difficult, because the there are two many value combinations. 

We solve the first problem by taking a random sample of unique values that are used in the algorithm[^extrapolation] (but always including the minimum and maximum of the variables involved to obtain a picture of the whole range of both variables). The reduction of the number of values that is achieved with this strategy also makes visualization easier. Another option for visualization, if reduction of unique values is not desirable, is to use three dimensional plots, as displayed in Figure \ref{fig:int_3d}. [WOULDBE BETTER TO HAVE ONE WITH OUR EXAMPLE]

[^extrapolation]: It is also possible to use an evenly spaced grid, however, this may result in extrapolation. Both of these options are implemented in our \texttt{R} package.

Theoretically, higher order interactions could be detected in this way as well. If, for instance, a potential three-way interaction is considered, all combinations of the unique values of the three variable can be obtained and partial dependence can be calculated. In addition to the computational demand of such a procedure, the partial dependence itself is difficult to interpret and is almost exclusively useful when visualized. In practice, it is therefore hard to consider interactions of a higher order for substantive interpretation[^interaction]. In order to screen the set of explanatory variables for interactions, the partial dependence of all variable pairs has to be calculated and visually inspected. Depending on the number of predictor variables this procedure might be computationally and time intensive. However, we our software optionally parallelizes the computation of partial dependence making it possible to distribute the task across multiple computers.

[^interaction]: Although it is difficult to interpret these higher order interactions, they are still detected by the Random Forest algorithm and built into the model after it is fitted. The information from such higher order interactions is therefore still contained in predictions obtained from the forest.

Another method of detecting interactions from Random Forests does not rely so heavily on visualization. Instead, it uses maximal $v$-subtrees and minimal depth [@ishwaran2007variable; @ishwaran2010high; @ishwaran2011random]. The basic idea behind this method for interaction detection is the fact that in CART variables that are used for splits on a higher level (i.e. closer to the root node) have higher importance for prediction.[^vimp] The measure of interactive importance of two variables, say $\mathbf{v}$ and $\mathbf{w}$ is the depth of the first split on $\mathbf{w}$ within a tree that is defined by the first split on $\mathbf{v}$. More formally, @ishwaran2010high introduce the concept of a maximal $\mathbf{v}$-subtree. A maximal subtree for a variable $\mathbf{v}$ is the largest subtree of a tree that has as its root node a split on $\mathbf{v}$, and no split on $\mathbf{v}$ in the parent nodes of this root node. The minimal depth for variable $\mathbf{v}$ is the distance between the highest maximal subtree for variable $\mathbf{v}$ and the root node of the whole tree. The minimal depth is therefore a measure of the predictive importance of $\mathbf{v}$. Interactions between pairs of variables $\mathbf{v}$ and $\mathbf{w}$ can be detected, by calculating the minimal depth of $\mathbf{w}$ in the maximal subtree of $\mathbf{v}$ and averaging this measure over all trees in the forest. This calculation gives a matrix of size $p \times p$ (recall that $p$ is the number of variables), that has on the diagonal the importance (according to the minimal depth criterion) of each variable, and on the off-diagonal elements the importance of the pairs of variables. This matrix can be easily scanned for rows that have a high importance on the diagonal entry and high importance on the off diagonals indicating interactions with these variables.[^visu]

[DO YOU WANT TO DISCUSS JOINT PERMUTATION IMPORTANCE HERE OR JUST THE FOOTNOTE?]

This method can only detect interactions between pairs of variables. There are, to our knowledge, no direct ways to detect and interpret interactions of higher orders. However, the interactions are still contained in the fitted forest. This means, the information about these interactions are contained in all predictions and, when they exist, discovered by multivariate partial dependence plots.

[^vimp]: This fact can also be used to create a measure of variable importance; an alternative to the permutation importance measure described above.
[^visu]: We are currently working on the implementation of a visualization tool for this method across packages. Currently maximal subtrees and minimal depth can only be obtained from the \texttt{randomForestSRC} package.

### Similarity and Clustering

Random Forests can furthermore be used to to understand the similarity between observations in the predictor space, after the forest has been fit. To obtain the similarity of observations, a proximity matrix is calculated, which is an $n$ by $n$ matrix where each entry gives the proportion of times that observation $i$ is in the same terminal node as observation $j$ across all the terminal nodes in the different trees of the forest. Since observations that have similar $\mathbf{x}$ values 'travel' the same way on splits more often than values with dissimilar values, the co-occurence in terminal nodes is a suitable measure of similarity. 

In order to interpret this large proximity matrix, matrix factorization methods such as principle components analysis (PCA) can be used to visualize the similarity of the observations on two dimensions of the approximation to the proximity matrix. PCA can be effectively visualized using a biplot [@gabriel1971biplot]. Our software provides a unified interface for extracting and visualizing proximity matrices. We also make it easy to layer additional variables on top of a biplot, e.g., colouring observations according to their level of some predictor as we show in Figure \ref{fig:prox}.

\input{figures/latex_subfloats/proximity.tex}

In Figure \ref{fig:prox_top} observations are coloured by their treatment condition, and in Figure \ref{fig:prox_bottom}, by whether or not they voted (the outcome of interest). The point shape shows whether or not the individual voted in 2008, and the size of the point gives the individual's age on election day. Clearly the first component (the $x$-axis) is whether or not the individual voted in 2008, and the second component is treatment status. Age appears to be less directly relevant, though it may be indirectly relevant. Similar figures for Random Forests predicting whether or not an individual votes regardless of whether they registered and for registration can be found in the appendix. Decompositions of the proximity matrix can provide additional information about the importance of the explanatory variables when they account for a relatively large portion of the variance of the proximity matrix. In this case whether or not an individual voted in 2008 and their treatment status were the dominant axes, however it appears that treatment status is less important than previous voting.

When individual data points are labelled these visualizations of the proximity matrix can provide additional insight into similarity between units conditional on the relationship between the explanatory variables and the outcome as discovered by the Random Forest. Figure (INSERT FIGURE LINK) shows a biplot of the first two principal components applied to a Random Forest fit to the human rights data. INSERT MORE DESCRIPTION HERE

## Limitations

Random Forests are not without issue however. The CART which they are composed of often rely on biased splitting criteria: some types of variables, specifically variables with many unique values, are artificially preferred to variables with fewer categories [@hothorn2006unbiased; @strobl2007bias]. These biases can also affect the measures of variable importance. Recent developments have resulted in unbiased recursive partitioning algorithms that separate the variable selection and split selection parts of the CART algorithm, and utilize subsampling rather than bootstrapping [@hothorn2006unbiased]. The analyses in this paper are done using this unbiased algorithm. 

Furthermore, as with many other methods, Random Forests utilize methods which assume that the observations in the sample are independent. Theoretical results regarding the consistency of Random Forests for estimation of moments (e.g., the mean) of the conditional distribution of the outcome rely on this assumption, and there is evidence to suggest that violation of this assumption results in degradation of predictive performance [@breiman2001random; @wager2015uniform]. There are several ways of dealing with this issue.

First, features of the dependence structure can often be incorporated as explanatory variables. Then, at each node in each tree in the forest, these variables have a chance of being included in the set of variables that may be split on. This means that if an explanatory variable has a relationship with the outcome that changes across different units, time, etc., this can be detected if the structure is included in this way. However, when such a description of the data structure results in high dimensional unordered categorical variables, this is computationally intensive and not always possible. As mentioned in the section on CART, inclusion of a countty indicator might already be prohibitive if there are more than 20 countries.

Second, there exist a variety of nonparametric resampling methods (e.g., the block boostrap) which can be used in place of independent bootstrapping. The generalized moving block bootstrap, transformation based bootstraps, or model-based (filtering) bootstrapping are examples, but the appropriateness of any particular method is context specific [@lahiri2003resampling]. Using an appropriate resampling method that only exchanges statistically independent observations has the effect of decreasing the correlation between trees in the forest, making them more diverse, and consequentially reducing variance [@breiman2001random]. A Random Forest with trees grown on data that are bootstrapped in a way that does not take into account the dependence structure will produce more highly correlated predictions and higher variance predictions.

Lastly, a random effects approach could be used: the outcome of interest is treated as a function of an unknown regression function which is estimated using Random Forests. The error is decomposed into variance attributable to aspects of the dependence specified in a linear mixed-effects model and idiosyncratic error. This improves predictions by using variance unexplained by the Random Forest but attributable to features of the dependence structure [@hajjem2014mixed; @hajjem2011mixed]. However, this method is currently limited to regression problems.

## Conclusion

With the rise of big data and the increasing prominence of computationally intensive methods of analysis, machine learning algorithms have moved more into the focus of attention of social science scholars. A very prominent algorithm in this group is the Random Forest. Although, it is very common in other disciplines, it has not been widely used in political science. We suspect that this is in part due to the believe that machine learning models, that are primarily designed to achieve good predictive performance, are black boxes that are not helpful for theory-seeking substantive research [@breiman2001statistical; @clark2015big]. 



In this paper we introduced Random Forest in detail and demonstrated its potential for substantive research in exploratory settings. Through various methods substantive  In situations where relevant theory says little about the functional form of the relationship of interest, the magnitude and degree of nonlinearity and interaction is unknown, the number of possibly relevant predictors is large, or when prediction is important, Random Forests may be a very useful tool for applied political science researchers.



 as well as software to reduce the technical burden of their use. Random Forests are but one member of a broad class of supervised machine learning methods that could be useful to political scientists. We hope that in the future these methods and the issues that they are designed to solve are incorporated into political science. Particularly, we see the development of machine learning methods for dependent data as a fruitful area for future research.

# References
